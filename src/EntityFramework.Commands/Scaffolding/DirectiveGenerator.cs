// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml.Linq;
using JetBrains.Annotations;
using Microsoft.Data.Entity.Internal;
using Microsoft.Data.Entity.Utilities;

namespace Microsoft.Data.Entity.Scaffolding
{
    /// <summary>
    ///     Produces runtime directive xml from reflection objects
    /// </summary>
    public class DirectiveGenerator
    {
        private static readonly XNamespace ns = "http://schemas.microsoft.com/netfx/2013/01/metadata";
        private static readonly XAttribute DynamicRequiredAll = new XAttribute("Dynamic", "Required All");
        private static readonly XAttribute DynamicRequired = new XAttribute("Dynamic", "Required");
        private static readonly XComment AutogenComment = new XComment(CommandsStrings.AutogeneratedDirectivesFiles);

        private readonly Dictionary<string, XElement> _typeDirectiveCache = new Dictionary<string, XElement>();
        private readonly HashSet<string> _methodInstantiationCache = new HashSet<string>();

        private static string GetXmlTypeName(Type type)
            => GetXmlTypeName(type.GetTypeInfo());

        private static string GetXmlTypeName(TypeInfo typeInfo)
        {
            var sb = new StringBuilder((typeInfo.FullName ?? typeInfo.Name).Split('`')[0]);

            var typeArgs = typeInfo.ContainsGenericParameters
                ? typeInfo.GenericTypeParameters
                : typeInfo.GenericTypeArguments;

            if (typeArgs.Length > 0)
            {
                sb.Append("{");
                sb.Append(string.Join(",", typeArgs.Select(GetXmlTypeName)));
                sb.Append("}");
            }

            return sb.ToString();
        }

        private static XElement CreateMethodInstantiationDirective(MethodInfo methodInfo)
            => new XElement(ns + "MethodInstantiation",
                new XAttribute("Name", methodInfo.Name),
                new XAttribute("Arguments", string.Join(", ", methodInfo.GetGenericArguments().Select(GetXmlTypeName))),
                DynamicRequired
                );

        private static XElement CreateTypeInstantiationDirective(TypeInfo typeInfo)
            => new XElement(ns + "TypeInstantiation",
                new XAttribute("Name", typeInfo.FullName.Split('`')[0]),
                new XAttribute("Arguments", string.Join(", ", typeInfo.GenericTypeArguments.Select(GetXmlTypeName))),
                DynamicRequiredAll);

        private static XElement CreateTypeDirective(TypeInfo typeInfo)
            => new XElement(ns + "Type",
                new XAttribute("Name", GetXmlTypeName(typeInfo)),
                DynamicRequiredAll);

        public virtual string GenerateXml([NotNull] ICollection<MemberInfo> members)
        {
            Check.NotNull(members, nameof(members));

            var document = new XDocument(new XDeclaration("1.0", "utf-8", "yes"));
            document.Add(AutogenComment);

            var root = new XElement(ns + "Directives", new XAttribute("xmlns", ns));
            document.Add(root);

            var library = new XElement(ns + "Library");
            root.Add(library);

            foreach (var member in members)
            {
                var typeInfo = member as TypeInfo;
                if (typeInfo != null)
                {
                    GetOrAddType(library, typeInfo);
                    continue;
                }

                var methodInfo = member as MethodInfo;
                if (methodInfo != null)
                {
                    GetOrAddGenericMethod(library, methodInfo);
                }
            }

            return document.ToString();
        }

        private void GetOrAddGenericMethod(XElement library, MethodInfo methodInfo)
        {
            var declaringType = methodInfo.DeclaringType.GetTypeInfo();
            var typeElement = GetOrAddType(library, declaringType);
            var methodElement = CreateMethodInstantiationDirective(methodInfo);

            var key = declaringType.FullName + ":" + methodElement;
            if (_methodInstantiationCache.Contains(key))
            {
                return;
            }

            typeElement.Add(methodElement);
            _methodInstantiationCache.Add(key);
        }

        private XElement GetOrAddType(XElement library, TypeInfo typeInfo)
        {
            XElement directive;
            var key = typeInfo.FullName;
            if (!_typeDirectiveCache.TryGetValue(key, out directive))
            {
                if ((typeInfo.GenericTypeArguments.Length > 0)
                    && !typeInfo.ContainsGenericParameters)
                {
                    directive = CreateTypeInstantiationDirective(typeInfo);
                }
                else
                {
                    directive = CreateTypeDirective(typeInfo);
                }

                _typeDirectiveCache.Add(key, directive);
                library.Add(directive);
            }

            return directive;
        }
    }
}
